# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import sys
from typing import Any, AsyncIterable, Callable, Dict, IO, Optional, TypeVar, Union, cast, overload
from urllib.parse import parse_qs, urljoin, urlparse

from azure.core.async_paging import AsyncItemPaged, AsyncList
from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict
from azure.mgmt.core.exceptions import ARMErrorFormat

from ...operations._operations import build_fulfillment_operations_activate_subscription_request, build_fulfillment_operations_delete_subscription_request, build_fulfillment_operations_get_subscription_request, build_fulfillment_operations_list_available_plans_request, build_fulfillment_operations_list_subscriptions_request, build_fulfillment_operations_resolve_request, build_fulfillment_operations_update_subscription_request, build_subscription_operations_get_operation_status_request, build_subscription_operations_list_operations_request, build_subscription_operations_update_operation_status_request
if sys.version_info >= (3, 9):
    from collections.abc import MutableMapping
else:
    from typing import MutableMapping  # type: ignore  # pylint: disable=ungrouped-imports
JSON = MutableMapping[str, Any] # pylint: disable=unsubscriptable-object
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class FulfillmentOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.marketplace.aio.SaaSAPI`'s
        :attr:`fulfillment_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def resolve(
        self,
        *,
        x_ms_marketplace_token: str,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Resolve a subscription.

        The resolve endpoint enables the publisher to resolve a marketplace token to a persistent
        resource ID. The resource ID is the unique identifier for a SaaS subscription. When a user is
        redirected to a partner's website, the URL contains a token in the query parameters. The
        partner is expected to use this token and make a request to resolve it. The response contains
        the unique SaaS subscription ID, name, offer ID, and plan for the resource. This token is valid
        for one hour only.

        :keyword x_ms_marketplace_token: The token query parameter in the URL when the user is
         redirected to the SaaS partner's website from Azure (for example,
         https://contoso.com/signup?token=..). Note, The URL decodes the token value from the browser
         before using it. Required.
        :paramtype x_ms_marketplace_token: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "id": "str",  # Optional.
                    "offerId": "str",  # Optional.
                    "planId": "str",  # Optional.
                    "quantity": 0,  # Optional.
                    "subscription": {
                        "allowedCustomerOperations": [
                            "str"  # Optional.
                        ],
                        "autoRenew": bool,  # Optional. Indicating whether the subscription
                          will renew automatically.
                        "beneficiary": {
                            "emailId": "str",  # Optional.
                            "objectId": "str",  # Optional.
                            "puid": "str",  # Optional.
                            "tenantId": "str"  # Optional.
                        },
                        "created": "2020-02-20 00:00:00",  # Optional.
                        "fulfillmentId": "str",  # Optional.
                        "id": "str",  # Optional.
                        "isFreeTrial": bool,  # Optional. true - the customer subscription is
                          currently in free trial, false - the customer subscription is not currently
                          in free trial.(optional field - default false).
                        "isTest": bool,  # Optional. Indicating whether the current
                          subscription is a test asset.
                        "name": "str",  # Optional.
                        "offerId": "str",  # Optional.
                        "planId": "str",  # Optional.
                        "publisherId": "str",  # Optional.
                        "purchaser": {
                            "emailId": "str",  # Optional.
                            "objectId": "str",  # Optional.
                            "puid": "str",  # Optional.
                            "tenantId": "str"  # Optional.
                        },
                        "quantity": 0,  # Optional.
                        "saasSubscriptionStatus": "str",  # Optional. Indicates the status of
                          the operation. Known values are: "NotStarted", "PendingFulfillmentStart",
                          "Subscribed", "Suspended", and "Unsubscribed".
                        "sandboxType": "str",  # Optional. Possible Values are None, Csp (Csp
                          sandbox purchase). Known values are: "None" and "Csp".
                        "sessionId": "str",  # Optional.
                        "sessionMode": "str",  # Optional. Dry Run indicates all transactions
                          run as Test-Mode in the commerce stack. Known values are: "None" and
                          "DryRun".
                        "storeFront": "str",  # Optional.
                        "term": {
                            "endDate": "2020-02-20 00:00:00",  # Optional.
                            "startDate": "2020-02-20 00:00:00"  # Optional.
                        }
                    },
                    "subscriptionName": "str"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_fulfillment_operations_resolve_request(
            x_ms_marketplace_token=x_ms_marketplace_token,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace
    def list_subscriptions(
        self,
        *,
        continuation_token_parameter: Optional[str] = None,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> AsyncIterable[JSON]:
        """List subscriptions.

        Lists all the SaaS subscriptions for a publisher.

        :keyword continuation_token_parameter: Optional value, only used for ListSubscriptions. Default
         value is None.
        :paramtype continuation_token_parameter: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: An iterator like instance of JSON object
        :rtype: ~azure.core.async_paging.AsyncItemPaged[JSON]
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "allowedCustomerOperations": [
                        "str"  # Optional.
                    ],
                    "autoRenew": bool,  # Optional. Indicating whether the subscription will
                      renew automatically.
                    "beneficiary": {
                        "emailId": "str",  # Optional.
                        "objectId": "str",  # Optional.
                        "puid": "str",  # Optional.
                        "tenantId": "str"  # Optional.
                    },
                    "created": "2020-02-20 00:00:00",  # Optional.
                    "fulfillmentId": "str",  # Optional.
                    "id": "str",  # Optional.
                    "isFreeTrial": bool,  # Optional. true - the customer subscription is
                      currently in free trial, false - the customer subscription is not currently in
                      free trial.(optional field - default false).
                    "isTest": bool,  # Optional. Indicating whether the current subscription is a
                      test asset.
                    "name": "str",  # Optional.
                    "offerId": "str",  # Optional.
                    "planId": "str",  # Optional.
                    "publisherId": "str",  # Optional.
                    "purchaser": {
                        "emailId": "str",  # Optional.
                        "objectId": "str",  # Optional.
                        "puid": "str",  # Optional.
                        "tenantId": "str"  # Optional.
                    },
                    "quantity": 0,  # Optional.
                    "saasSubscriptionStatus": "str",  # Optional. Indicates the status of the
                      operation. Known values are: "NotStarted", "PendingFulfillmentStart",
                      "Subscribed", "Suspended", and "Unsubscribed".
                    "sandboxType": "str",  # Optional. Possible Values are None, Csp (Csp sandbox
                      purchase). Known values are: "None" and "Csp".
                    "sessionId": "str",  # Optional.
                    "sessionMode": "str",  # Optional. Dry Run indicates all transactions run as
                      Test-Mode in the commerce stack. Known values are: "None" and "DryRun".
                    "storeFront": "str",  # Optional.
                    "term": {
                        "endDate": "2020-02-20 00:00:00",  # Optional.
                        "startDate": "2020-02-20 00:00:00"  # Optional.
                    }
                }
        """
        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        error_map = {
            401: ClientAuthenticationError,
            404: ResourceNotFoundError,
            409: ResourceExistsError,
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})
        def prepare_request(next_link=None):
            if not next_link:
                
                request = build_fulfillment_operations_list_subscriptions_request(
                    continuation_token_parameter=continuation_token_parameter,
                    request_id_parameter=request_id_parameter,
                    correlation_id=correlation_id,
                    api_version=self._config.api_version,
                    headers=_headers,
                    params=_params,
                )
                request.url = self._client.format_url(request.url)  # type: ignore

            else:
                # make call to next link with the client's api-version
                _parsed_next_link = urlparse(next_link)
                _next_request_params = case_insensitive_dict(parse_qs(_parsed_next_link.query))
                _next_request_params["api-version"] = self._config.api_version
                request = HttpRequest("GET", urljoin(next_link, _parsed_next_link.path), params=_next_request_params)
                request.url = self._client.format_url(request.url)  # type: ignore

            return request

        async def extract_data(pipeline_response):
            deserialized = pipeline_response.http_response.json()
            list_of_elem = deserialized["subscriptions"]
            if cls:
                list_of_elem = cls(list_of_elem)
            return deserialized.get("@nextLink", None), AsyncList(list_of_elem)

        async def get_next(next_link=None):
            request = prepare_request(next_link)

            pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
                request,
                stream=False,
                **kwargs
            )
            response = pipeline_response.http_response

            if response.status_code not in [200]:
                map_error(status_code=response.status_code, response=response, error_map=error_map)
                raise HttpResponseError(response=response, error_format=ARMErrorFormat)

            return pipeline_response


        return AsyncItemPaged(
            get_next, extract_data
        )


    @distributed_trace_async
    async def get_subscription(
        self,
        subscription_id: str,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Get subscription.

        Gets the specified SaaS subscription. Use this call to get license information and plan
        information.

        :param subscription_id: Required.
        :type subscription_id: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "allowedCustomerOperations": [
                        "str"  # Optional.
                    ],
                    "autoRenew": bool,  # Optional. Indicating whether the subscription will
                      renew automatically.
                    "beneficiary": {
                        "emailId": "str",  # Optional.
                        "objectId": "str",  # Optional.
                        "puid": "str",  # Optional.
                        "tenantId": "str"  # Optional.
                    },
                    "created": "2020-02-20 00:00:00",  # Optional.
                    "fulfillmentId": "str",  # Optional.
                    "id": "str",  # Optional.
                    "isFreeTrial": bool,  # Optional. true - the customer subscription is
                      currently in free trial, false - the customer subscription is not currently in
                      free trial.(optional field - default false).
                    "isTest": bool,  # Optional. Indicating whether the current subscription is a
                      test asset.
                    "name": "str",  # Optional.
                    "offerId": "str",  # Optional.
                    "planId": "str",  # Optional.
                    "publisherId": "str",  # Optional.
                    "purchaser": {
                        "emailId": "str",  # Optional.
                        "objectId": "str",  # Optional.
                        "puid": "str",  # Optional.
                        "tenantId": "str"  # Optional.
                    },
                    "quantity": 0,  # Optional.
                    "saasSubscriptionStatus": "str",  # Optional. Indicates the status of the
                      operation. Known values are: "NotStarted", "PendingFulfillmentStart",
                      "Subscribed", "Suspended", and "Unsubscribed".
                    "sandboxType": "str",  # Optional. Possible Values are None, Csp (Csp sandbox
                      purchase). Known values are: "None" and "Csp".
                    "sessionId": "str",  # Optional.
                    "sessionMode": "str",  # Optional. Dry Run indicates all transactions run as
                      Test-Mode in the commerce stack. Known values are: "None" and "DryRun".
                    "storeFront": "str",  # Optional.
                    "term": {
                        "endDate": "2020-02-20 00:00:00",  # Optional.
                        "startDate": "2020-02-20 00:00:00"  # Optional.
                    }
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_fulfillment_operations_get_subscription_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @overload
    async def update_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: JSON,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Patch a subscription.

        Use this call to update the plan, the user count (quantity), or both.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Required.
        :type body: JSON
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "planId": "str",  # Optional.
                    "quantity": 0  # Optional.
                }
        """

    @overload
    async def update_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: IO,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Patch a subscription.

        Use this call to update the plan, the user count (quantity), or both.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Required.
        :type body: IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """


    @distributed_trace_async
    async def update_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: Union[JSON, IO],
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Patch a subscription.

        Use this call to update the plan, the user count (quantity), or both.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_fulfillment_operations_update_subscription_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace_async
    async def delete_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Delete a subscription.

        Unsubscribe and delete the specified subscription.

        :param subscription_id: Required.
        :type subscription_id: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_fulfillment_operations_delete_subscription_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [202]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        response_headers = {}
        response_headers['Operation-Location']=self._deserialize('str', response.headers.get('Operation-Location'))


        if cls:
            return cls(pipeline_response, None, response_headers)



    @distributed_trace_async
    async def list_available_plans(
        self,
        subscription_id: str,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """List available plans.

        Use this call to find out if there are any private or public offers for the current publisher.

        :param subscription_id: Required.
        :type subscription_id: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "plans": [
                        {
                            "description": "str",  # Optional.
                            "displayName": "str",  # Optional.
                            "hasFreeTrials": bool,  # Optional.
                            "isPricePerSeat": bool,  # Optional.
                            "isPrivate": bool,  # Optional.
                            "isStopSell": bool,  # Optional.
                            "market": "str",  # Optional.
                            "planComponents": {
                                "meteringDimensions": [
                                    {
                                        "currency": "str",  # Optional.
                                        "displayName": "str",  # Optional.
                                        "id": "str",  # Optional.
                                        "pricePerUnit": 0.0,  # Optional.
                                        "unitOfMeasure": "str"  # Optional.
                                    }
                                ],
                                "recurrentBillingTerms": [
                                    {
                                        "currency": "str",  # Optional.
                                        "meteredQuantityIncluded": [
                                            {
                                                "dimensionId": "str",
                                                  # Optional.
                                                "units": "str"  #
                                                  Optional.
                                            }
                                        ],
                                        "price": 0.0,  # Optional.
                                        "termDescription": "str",  #
                                          Optional.
                                        "termUnit": "str"  # Optional. Known
                                          values are: "P1M" and "P1Y".
                                    }
                                ]
                            },
                            "planId": "str"  # Optional.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_fulfillment_operations_list_available_plans_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @overload
    async def activate_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: JSON,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Activate a subscription.

        Use this call to activate a subscription.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Required.
        :type body: JSON
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "planId": "str",  # Optional.
                    "quantity": 0  # Optional.
                }
        """

    @overload
    async def activate_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: IO,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Activate a subscription.

        Use this call to activate a subscription.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Required.
        :type body: IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """


    @distributed_trace_async
    async def activate_subscription(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        body: Union[JSON, IO],
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Activate a subscription.

        Use this call to activate a subscription.

        :param subscription_id: Required.
        :type subscription_id: str
        :param body: Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_fulfillment_operations_activate_subscription_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


class SubscriptionOperationsOperations:
    """
    .. warning::
        **DO NOT** instantiate this class directly.

        Instead, you should access the following operations through
        :class:`~azure.marketplace.aio.SaaSAPI`'s
        :attr:`subscription_operations` attribute.
    """

    def __init__(self, *args, **kwargs) -> None:
        input_args = list(args)
        self._client = input_args.pop(0) if input_args else kwargs.pop("client")
        self._config = input_args.pop(0) if input_args else kwargs.pop("config")
        self._serialize = input_args.pop(0) if input_args else kwargs.pop("serializer")
        self._deserialize = input_args.pop(0) if input_args else kwargs.pop("deserializer")


    @distributed_trace_async
    async def list_operations(
        self,
        subscription_id: str,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """List outstanding operations.

        Lists the outstanding operations for the current publisher.

        :param subscription_id: Required.
        :type subscription_id: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "operations": [
                        {
                            "action": "str",  # Optional. Known values are:
                              "Unsubscribe", "ChangePlan", "ChangeQuantity", "Suspend", and
                              "Reinstate".
                            "activityId": "str",  # Optional.
                            "id": "str",  # Optional.
                            "offerId": "str",  # Optional.
                            "planId": "str",  # Optional.
                            "publisherId": "str",  # Optional.
                            "quantity": 0,  # Optional.
                            "status": "str",  # Optional. Known values are: "NotStarted",
                              "InProgress", "Succeeded", "Failed", and "Conflict".
                            "subscriptionId": "str",  # Optional.
                            "timeStamp": "2020-02-20 00:00:00"  # Optional.
                        }
                    ]
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_subscription_operations_list_operations_request(
            subscription_id=subscription_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @distributed_trace_async
    async def get_operation_status(
        self,
        subscription_id: str,
        operation_id: str,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> JSON:
        """Get operation status.

        Enables the publisher to track the status of the specified triggered async operation (such as
        Subscribe, Unsubscribe, ChangePlan, or ChangeQuantity).

        :param subscription_id: Required.
        :type subscription_id: str
        :param operation_id: Required.
        :type operation_id: str
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :return: JSON object
        :rtype: JSON
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # response body for status code(s): 200
                response == {
                    "action": "str",  # Optional. Known values are: "Unsubscribe", "ChangePlan",
                      "ChangeQuantity", "Suspend", and "Reinstate".
                    "activityId": "str",  # Optional.
                    "id": "str",  # Optional.
                    "offerId": "str",  # Optional.
                    "planId": "str",  # Optional.
                    "publisherId": "str",  # Optional.
                    "quantity": 0,  # Optional.
                    "status": "str",  # Optional. Known values are: "NotStarted", "InProgress",
                      "Succeeded", "Failed", and "Conflict".
                    "subscriptionId": "str",  # Optional.
                    "timeStamp": "2020-02-20 00:00:00"  # Optional.
                }
        """
        error_map = {
            401: ClientAuthenticationError,
            409: ResourceExistsError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[JSON]

        
        request = build_subscription_operations_get_operation_status_request(
            subscription_id=subscription_id,
            operation_id=operation_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            api_version=self._config.api_version,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if response.content:
            deserialized = response.json()
        else:
            deserialized = None

        if cls:
            return cls(pipeline_response, cast(JSON, deserialized), {})

        return cast(JSON, deserialized)



    @overload
    async def update_operation_status(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        operation_id: str,
        body: JSON,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update the status of an operation.

        Update the status of an operation to indicate success or failure with the provided values.

        :param subscription_id: Required.
        :type subscription_id: str
        :param operation_id: Required.
        :type operation_id: str
        :param body: Required.
        :type body: JSON
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for JSON body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:

        Example:
            .. code-block:: python

                # JSON input template you can fill out and use as your body input.
                body = {
                    "planId": "str",  # Optional.
                    "quantity": 0,  # Optional.
                    "status": "str"  # Optional. Known values are: "Success" and "Failure".
                }
        """

    @overload
    async def update_operation_status(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        operation_id: str,
        body: IO,
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        content_type: str = "application/json",
        **kwargs: Any
    ) -> None:
        """Update the status of an operation.

        Update the status of an operation to indicate success or failure with the provided values.

        :param subscription_id: Required.
        :type subscription_id: str
        :param operation_id: Required.
        :type operation_id: str
        :param body: Required.
        :type body: IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Content type parameter for binary body.
         Default value is "application/json".
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """


    @distributed_trace_async
    async def update_operation_status(  # pylint: disable=inconsistent-return-statements
        self,
        subscription_id: str,
        operation_id: str,
        body: Union[JSON, IO],
        *,
        request_id_parameter: Optional[str] = None,
        correlation_id: Optional[str] = None,
        **kwargs: Any
    ) -> None:
        """Update the status of an operation.

        Update the status of an operation to indicate success or failure with the provided values.

        :param subscription_id: Required.
        :type subscription_id: str
        :param operation_id: Required.
        :type operation_id: str
        :param body: Is either a model type or a IO type. Required.
        :type body: JSON or IO
        :keyword request_id_parameter: A unique string value for tracking the request from the client,
         preferably a GUID. If this value isn't provided, one will be generated and provided in the
         response headers. Default value is None.
        :paramtype request_id_parameter: str
        :keyword correlation_id: A unique string value for operation on the client. This parameter
         correlates all events from client operation with events on the server side. If this value isn't
         provided, one will be generated and provided in the response headers. Default value is None.
        :paramtype correlation_id: str
        :keyword content_type: Body Parameter content-type. Known values are: 'application/json'.
         Default value is None.
        :paramtype content_type: str
        :return: None
        :rtype: None
        :raises ~azure.core.exceptions.HttpResponseError:
        """
        error_map = {
            401: ClientAuthenticationError,
            400: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            403: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
            404: lambda response: ResourceNotFoundError(response=response, error_format=ARMErrorFormat),
            409: lambda response: ResourceExistsError(response=response, error_format=ARMErrorFormat),
            500: lambda response: HttpResponseError(response=response, error_format=ARMErrorFormat),
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', None))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        content_type = content_type or "application/json"
        _json = None
        _content = None
        if isinstance(body, (IO, bytes)):
            _content = body
        else:
            _json = body

        request = build_subscription_operations_update_operation_status_request(
            subscription_id=subscription_id,
            operation_id=operation_id,
            request_id_parameter=request_id_parameter,
            correlation_id=correlation_id,
            content_type=content_type,
            api_version=self._config.api_version,
            json=_json,
            content=_content,
            headers=_headers,
            params=_params,
        )
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )

        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response, error_format=ARMErrorFormat)

        if cls:
            return cls(pipeline_response, None, {})


